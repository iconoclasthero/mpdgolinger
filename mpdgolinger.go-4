package main

import (
	"bufio"
	"fmt"
	"log"
	"net"
	"os"
	"strconv"
	"strings"
	"sync"
	"time"

	"github.com/fhs/gompd/v2/mpd"
)

// State holds daemon state
type State struct {
	mu         sync.Mutex
	paused     bool
	count      int        // current position in block
	limit      int        // persistent block size (your old "limit")
	blockLimit int        // temporary override (later)
	transition bool       // true between last-song-start and next-song-start
	lastSongID string
	pollMode   int
}

const (
	PollOff = iota
	PollLogging
	PollOn
)

var (
	state   = &State{limit: 3, pollMode: PollOff}
	mpdHost = "localhost:6600"
)

func main() {
	// Connect to MPD to get initial status
	err := safeMPD(func(c *mpd.Client) error {
		status, err := c.Status()
		if err != nil {
			return err
		}
		state.lastSongID = status["songid"]
		switch status["state"] {
		case "paused", "stop":
			state.count = 0
		default:
			state.count = 1
		}
		return nil
	})
	if err != nil {
		log.Printf("Status error at startup: %v", err)
		state.count = 0
		state.lastSongID = ""
	}
	log.Printf("Starting block count=%d, lastSongID=%s", state.count, state.lastSongID)

	// Start IPC listener
	socketPath := "/tmp/mpdgolinger.sock"
	os.Remove(socketPath)
	go startIPC(socketPath)

	// Start poller with safeMPD
	go poller()

	// Start idle loop with supervisor
	go idleSupervisor()

	// Block forever
	select {}
}

// safeMPD wraps any MPD command with dial/retry logic
func safeMPD(cmd func(c *mpd.Client) error) error {
	for i := 0; i < 3; i++ {
		client, err := mpd.Dial("tcp", mpdHost)
		if err != nil {
			log.Printf("SafeMPD: dial failed: %v — retrying", err)
			time.Sleep(1 * time.Second)
			continue
		}
		err = cmd(client)
		client.Close()
		if err != nil {
			log.Printf("SafeMPD: command failed: %v — retrying", err)
			time.Sleep(1 * time.Second)
			continue
		}
		return nil
	}
	return fmt.Errorf("SafeMPD: all retries failed")
}

// idleSupervisor reconnects if the watcher dies
func idleSupervisor() {
	for {
		log.Println("Connecting to MPD for idle loop...")
		w, err := mpd.NewWatcher("tcp", mpdHost, "", "player")
		if err != nil {
			log.Printf("Watcher init failed: %v — retrying in 2s", err)
			time.Sleep(2 * time.Second)
			continue
		}

		if err := runIdleLoop(w); err != nil {
			log.Printf("Idle loop exited: %v — reconnecting in 2s", err)
		}
		w.Close()
		time.Sleep(2 * time.Second)
	}
}

// runIdleLoop handles events from the watcher
func runIdleLoop(w *mpd.Watcher) error {
	for range w.Event {
		// Fetch status safely
		var status map[string]string
		err := safeMPD(func(c *mpd.Client) error {
			var err error
			status, err = c.Status()
			return err
		})
		if err != nil {
			log.Printf("MPD status fetch failed: %v", err)
			continue
		}

		songID := status["songid"]

		state.mu.Lock()
		if songID == state.lastSongID {
			state.mu.Unlock()
			continue
		}
		state.lastSongID = songID

		if state.transition {
			_ = safeMPD(func(c *mpd.Client) error { return c.Random(false) })
			state.count = 1
			state.transition = false
			log.Printf("New block started — random OFF, count=%d", state.count)
		} else if state.count == state.limit-1 {
			state.count++
			_ = safeMPD(func(c *mpd.Client) error { return c.Random(true) })
			state.transition = true
			log.Printf("Song %d/%d — last song, random ON", state.count, state.limit)
		} else {
			state.count++
			log.Printf("Song %d/%d in current block", state.count, state.limit)
		}
		state.mu.Unlock()
	}
	return fmt.Errorf("watcher closed")
}

// poller optionally polls MPD based on pollMode
func poller() {
	for {
		state.mu.Lock()
		mode := state.pollMode
		state.mu.Unlock()

		if mode == PollOff {
			time.Sleep(time.Second)
			continue
		}

		var status map[string]string
		err := safeMPD(func(c *mpd.Client) error {
			var err error
			status, err = c.Status()
			return err
		})
		if err != nil {
			log.Printf("Poll status error: %v", err)
			time.Sleep(time.Second)
			continue
		}

		songID := status["songid"]

		state.mu.Lock()
		if mode == PollLogging {
			log.Printf("Poll logging: songid=%s", songID)
		} else if mode == PollOn && songID != state.lastSongID && !state.paused {
			state.count++
			if state.count >= state.blockLimit {
				state.count = 0
				log.Println("Poll: block finished — starting new block")
			} else {
				log.Printf("Poll: song %d/%d in current block", state.count, state.blockLimit)
			}
		}
		state.lastSongID = songID
		state.mu.Unlock()

		time.Sleep(1 * time.Second)
	}
}

// startIPC listens on UNIX socket for client commands
func startIPC(path string) {
	ln, err := net.Listen("unix", path)
	if err != nil {
		log.Fatalf("Failed to listen on %s: %v", path, err)
	}
	defer ln.Close()
	log.Printf("IPC listening on %s", path)

	for {
		conn, err := ln.Accept()
		if err != nil {
			log.Printf("IPC accept error: %v", err)
			continue
		}
		go handleConn(conn)
	}
}

// handleConn parses commands and updates state
func handleConn(conn net.Conn) {
	defer conn.Close()
	scanner := bufio.NewScanner(conn)
	for scanner.Scan() {
		line := scanner.Text()
		fields := strings.Fields(line)
		if len(fields) == 0 {
			continue
		}

		cmd := strings.ToLower(fields[0])
		switch cmd {
		case "pause":
			state.mu.Lock()
			state.paused = true
			state.mu.Unlock()
			fmt.Fprintln(conn, "Paused")
		case "resume":
			state.mu.Lock()
			state.paused = false
			state.mu.Unlock()
			fmt.Fprintln(conn, "Resumed")
		case "skip":
			state.mu.Lock()
			state.count = 0
			state.mu.Unlock()
			err := safeMPD(func(c *mpd.Client) error { return c.Next() })
			if err != nil {
				fmt.Fprintf(conn, "Skip failed: %v\n", err)
			} else {
				fmt.Fprintln(conn, "Skipped to next block")
			}
		case "setblock":
			if len(fields) < 2 {
				fmt.Fprintln(conn, "Usage: setblock N")
				continue
			}
			n, err := strconv.Atoi(fields[1])
			if err != nil || n <= 0 {
				fmt.Fprintln(conn, "Invalid block size")
				continue
			}
			state.mu.Lock()
			state.blockLimit = n
			state.count = 0
			state.mu.Unlock()
			fmt.Fprintf(conn, "Block limit set to %d\n", n)
		case "status":
			state.mu.Lock()
			fmt.Fprintf(conn, "paused=%v count=%d blockLimit=%d lastSongID=%s pollMode=%d\n",
				state.paused, state.count, state.blockLimit, state.lastSongID, state.pollMode)
			state.mu.Unlock()
		case "pollmode":
			if len(fields) < 2 {
				fmt.Fprintln(conn, "Usage: pollmode off|logging|on")
				continue
			}
			var mode int
			switch strings.ToLower(fields[1]) {
			case "off":
				mode = PollOff
			case "logging":
				mode = PollLogging
			case "on":
				mode = PollOn
			default:
				fmt.Fprintln(conn, "Invalid poll mode")
				continue
			}
			state.mu.Lock()
			state.pollMode = mode
			state.mu.Unlock()
			fmt.Fprintf(conn, "Poll mode set to %s\n", fields[1])
		default:
			fmt.Fprintln(conn, "Unknown command")
		}
	}
	if err := scanner.Err(); err != nil {
		log.Printf("IPC connection error: %v", err)
	}
}

package main

import (
  "flag"
	"bufio"
	"fmt"
	"log"
	"net"
	"os"
	"strconv"
	"strings"
	"sync"
	"time"

	"github.com/fhs/gompd/v2/mpd"
)

// State holds daemon state
type State struct {
	mu         sync.Mutex
	paused       bool
	count        int    // current position in block
//limit        int    // persistent block size  // removed from state as it will be computed
	blockLimit   int    // temporary override (later)
	transition   bool   // true between last-song-start and next-song-start
	lastSongID   string
	pollMode     int
  baseLimit    int
  blockActive  bool
}

const (
  defaultLimit = 3
	PollOff = iota
	PollLogging
	PollOn
  stateDefault = "/var/lib/mpd/mpdlinger/mpdgolinger.state"
)

var (
	state   = &State{baseLimit: defaultLimit,
                    pollMode: PollOff,
  }
  shutdown = make(chan struct{})
  statePath string
  stateEnabled bool
	mpdHost = "localhost:6600"
  socketPath = "/var/lib/mpd/mpdlinger/mpdgolinger.sock"
)

// central safe MPD executor
func mpdDo(fn func(c *mpd.Client) error, src string) error {
	c, err := mpd.Dial("tcp", mpdHost)
	if err != nil {
		log.Printf("[%s] MPD dial failed: %v", src, err)
		return err
	}
	defer c.Close()

	if err := fn(c); err != nil {
		log.Printf("[%s] MPD command failed: %v", src, err)
		return err
	}
	return nil
}

// wrapper to set MPD random state
func setRandom(on bool, src string) {
	_ = mpdDo(func(c *mpd.Client) error {
		return c.Random(on)
	}, src)
	log.Printf("STATE CHANGE: [%s] mpd random=%v", src, on)
}

// wrapper to skip next track
func mpdNext(src string) {
	_ = mpdDo(func(c *mpd.Client) error {
		return c.Next()
	}, src)
	log.Printf("STATE CHANGE: [%s] mpd next track", src)
}

// wrapper to play/pause
func mpdPlayPause(play bool, src string) {
	_ = mpdDo(func(c *mpd.Client) error {
		if play {
			return c.Play(-1)
		}
		return c.Pause(true)
	}, src)
	log.Printf("STATE CHANGE: [%s] mpd play=%v", src, play)
}

// logStateChange logs a standardized message for state transitions
func logStateChange(src, songID string, count, limit int, transition bool) {
	log.Printf(
		"STATE CHANGE: [%s]: songID=%s count=%d/limit=%d transition=%v",
		src, songID, count, limit, transition,
	)
}

// idleSupervisor maintains a persistent connection to MPD
func idleSupervisor() {
	for {
		log.Println("Connecting to MPD for idle loop...")
		w, err := mpd.NewWatcher("tcp", mpdHost, "", "player")
		if err != nil {
			log.Printf("Watcher init failed: %v — retrying in 2s", err)
			time.Sleep(2 * time.Second)
			continue
		}

		// run idle loop; if it exits, reconnect after 2s
		if err := runIdleLoop(w); err != nil {
			log.Printf("Idle loop exited: %v — reconnecting in 2s", err)
		}
		w.Close()
		time.Sleep(2 * time.Second)
	}
}



func logCurrentSong(c *mpd.Client, prefix string) {
    if c == nil {
        log.Printf("%s: currentsong skipped (nil client)", prefix)
        return
    }

    song, err := c.CurrentSong()
    if err != nil {
        log.Printf("%s: currentsong error: %v", prefix, err)
        return
    }

    file := song["file"]
    if file == "" {
        log.Printf("%s: currentsong: <no file field>", prefix)
        return
    }

    log.Printf("%s: currentsong file=%q", prefix, file)
}

/* THIS APPEARS TO BE WORKING!!! */
func runIdleLoop(w *mpd.Watcher) error {
  log.Println("MPD connection established, entering idle loop")

  // mpd.Watcher exposes an Error channel that reports lower-level
  // connection issues (EOF, broken pipe, protocol errors).
  //
  // IMPORTANT:
  //   These errors do *not* necessarily stop the Event channel,
  //   so we log them asynchronously for correlation only.
  //
  go func() {
    for err := range w.Error {
      // keep this very explicit so we can trace EOF vs broken pipe
      log.Printf("Watcher error: %v", err)
    }
  }()

  // Main idle loop:
  // For each idle event, open a short-lived command connection and run
  // status/commands via mpdDo (your safe wrapper).
  // Each value received from w.Event represents an MPD "idle"
  // notification for a specific subsystem (usually "player").
  //
  // MPD does NOT tell us *what* changed — only that *something*
  // in that subsystem did.
  //
  for subsystem := range w.Event {
      log.Printf("Idle event subsystem=%s", subsystem)

      // For *every* idle event we:
      //   • Open a fresh short-lived MPD connection
      //   • Query current status
      //   • Optionally toggle random
      //
      // This avoids:
      //   • idle/command protocol conflicts
      //   • stale connections after EOF
      //
      // Use mpdDo to make a fresh short-lived command connection
      err := mpdDo(func(c *mpd.Client) error {
          // Log the current song immediately on idle receipt.
          //
          // This gives us a "pre-status" snapshot so we can see:
          //   • what MPD *thought* was playing when idle fired
          //   • whether seek/pause events keep the same file
          //
          logCurrentSong(c, "idle event (pre-status)")

          // Fetch current player status.
          //
          // If this fails, the connection is already bad and the
          // supervisor must reconnect.
          //
          status, err := c.Status()
          if err != nil {
              // return so outer code treats this as a status error and reconnects
              return err
          }
          songID := status["songid"]

          // Protect shared FSM state.
          state.mu.Lock()

					// Compute the current limit
					limit := state.baseLimit
					if state.blockActive && state.blockLimit > 0 {
					    limit = state.blockLimit
					}

          // If the user pauses the linger functionality (and state.paused is true):
          if state.paused {
            if songID != state.lastSongID {
              state.lastSongID = songID
              state.count++ // keep counting while paused (matches bash behavior)
              log.Printf("Paused: song advanced, count=%d (limit=%d)", state.count, limit)
            } else {
              log.Printf("Paused: idle event, song unchanged")
            }

            state.mu.Unlock()
            return nil
          }

          // If songID did not change, this idle event was caused by:
          //   • seek
          //   • pause/resume
          //   • repeat/random toggles
          //   • other non-track-boundary events
          //
          if songID == state.lastSongID {
              // nothing changed; keep trace so we can see frequent idle hits
              log.Printf("Idle event received but songID unchanged: %s", songID)
              state.mu.Unlock()
              // Log currentsong again so we can verify the *file*
              // really stayed the same across the idle break.
              //
              logCurrentSong(c, "idle event (songID unchanged)")
              return nil
          }

          // From here on, MPD has started a *new song*.
          // Update the FSM accordingly.
          //
          prevCount := state.count
          prevTransition := state.transition
          state.lastSongID = songID

          if state.transition {
              // We were waiting for the first song *after* a random block.
              //
              // This is the moment to:
              //   • turn random OFF
              //   • reset the block counter
              //
              if err := c.Random(false); err != nil {
                  log.Printf("random(false) failed: %v", err)
                  // Do NOT abort: random failure should not desync FSM
              }

              state.count = 1
              state.transition = false
              log.Printf("Transition: random off, count reset to 1")

          } else if state.count == limit-1 {   // <- uses computed local limit
              // This song completes the block.
              //
              // We:
              //   • increment count
              //   • turn random ON
              //   • mark that the *next* song is a transition
              //
              state.count++
              if err := c.Random(true); err != nil {
                  log.Printf("random(true) failed: %v", err)
              }

              state.transition = true
              log.Printf("Last song in block reached: random on, transition true")

					    // Clear blockLimit after block completes
					    state.blockLimit = 0
					    state.blockActive = false

          } else {
              // Normal in-block advance.
              state.count++
              log.Printf("Normal increment: count=%d/%d", state.count, limit)
          }

          // Emit a structured state-change log so we can replay FSM
          // behavior purely from logs.
          //
          logStateChange(
              "idleLoop-event",
              songID,
              state.count,
              limit,
              state.transition,
          )

          // Log the song again *after* state changes and random toggles.
          // This lets us confirm whether MPD advanced tracks as expected.
          //
          logCurrentSong(c, "idle event (post-state-change)")

          _ = prevCount
          _ = prevTransition
          state.mu.Unlock()

          return nil

      }, "idleLoop-event")

      if err != nil {
          // Make the error explicit and return so idleSupervisor can reconnect
          // This distinguishes EOF/broken-pipe vs other errors in your logs
          // Any error here means:
          //   • status fetch failed
          //   • connection closed mid-command
          //   • protocol error
          //
          // We *want* to exit so the supervisor can reconnect.
          //
          log.Printf("MPD status fetch failed: %v — will attempt reconnect", err)

          // Best-effort logging of currentsong during failure path.
          // If this also fails, that's useful signal too.
          //
          _ = mpdDo(func(c *mpd.Client) error {
              logCurrentSong(c, "idle error path")
              return nil
          }, "idle-error-log")

          log.Println("MPD connection closed")
          return fmt.Errorf("status error: %w", err)
      }
  }

  // If we exit the loop, the watcher closed.
  return fmt.Errorf("watcher closed")
}



// poller optionally polls MPD based on pollMode
func poller(client *mpd.Client) {
	for {
		state.mu.Lock()
		mode := state.pollMode
		state.mu.Unlock()

		if mode == PollOff {
			time.Sleep(time.Second)
			continue
		}

		mpdDo(func(c *mpd.Client) error {
			status, err := c.Status()
			if err != nil {
				return err
			}
			songID := status["songid"]

			state.mu.Lock()
			defer state.mu.Unlock()

			if mode == PollLogging {
				log.Printf("Poll logging: songid=%s", songID)
			} else if mode == PollOn && songID != state.lastSongID && !state.paused {
				state.count++
				if state.count >= state.blockLimit {
					state.count = 0
					log.Println("Poll: block finished — starting new block")
				} else {
					log.Printf("Poll: song %d/%d in current block", state.count, state.blockLimit)
				}
			}
			state.lastSongID = songID
			return nil
		}, "poller")

		time.Sleep(1 * time.Second)
	}
}

// startIPC listens on UNIX socket for client commands
func startIPC(path string) {
	ln, err := net.Listen("unix", path)
	if err != nil {
		log.Fatalf("Failed to listen on %s: %v", path, err)
	}
	defer ln.Close()

  // Now the socket exists → set ownership and permissions
//  os.Chown(socketPath, uid, gid) // uid/gid for mpd user
  os.Chmod(socketPath, 0660)     // owner+group read/write

	log.Printf("IPC listening on %s", path)

	for {
		conn, err := ln.Accept()
		if err != nil {
			log.Printf("IPC accept error: %v", err)
			continue
		}
		go handleConn(conn)
	}
}

// handleConn parses commands and updates state
func handleConn(conn net.Conn) {
	defer conn.Close()
	scanner := bufio.NewScanner(conn)
	for scanner.Scan() {
		line := scanner.Text()
		fields := strings.Fields(line)
		if len(fields) == 0 {
			continue
		}

		cmd := strings.ToLower(fields[0])
		switch cmd {
    case "pause":
      log.Printf("IPC: received pause command")

      state.mu.Lock()
      state.paused = true
      state.mu.Unlock()

      fmt.Fprintln(conn, "Paused")

//    case "resume":
//      log.Printf("IPC: received resume command")
//
//      state.mu.Lock()
//      state.paused = false
//      state.transition = true // force new block on next idle
//      state.mu.Unlock()
//
//      fmt.Fprintln(conn, "Resumed")
		case "resume":
	    state.mu.Lock()
	    state.paused = false

	    // If block already exhausted while paused,
	    // force a clean block boundary on next song.
      limit := state.baseLimit
      if state.blockActive && state.blockLimit > 0 {
        limit = state.blockLimit
      }
	    expired := state.count >= limit
	    if expired {
	        state.transition = true
	    }

	    state.mu.Unlock()

	    if expired {
	        _ = mpdDo(func(c *mpd.Client) error {
	            return c.Random(true)
	        }, "IPC-resume")
	    }

	    // Resume playback unconditionally
	    mpdPlayPause(true, "IPC-resume")

	    log.Printf(
	        "STATE CHANGE: [IPC-resume] paused=false expired=%v count=%d limit=%d transition=%v",
	        expired, state.count, limit, state.transition,
	    )

	    fmt.Fprintln(conn, "Resumed")


//    case "next", "nextblock":
//      log.Printf("IPC COMMAND: nextBlock received")
//      fmt.Fprintln(conn, "OK")
    // next: force start of a new block; always resumes playback;
    // idle loop owns count reset and random-off transition
		case "next":
      log.Printf("IPC: received next command")
		  // imperative block advance
			state.mu.Lock()
			state.transition = true   // tell idle loop “new block boundary”
			state.paused = false      // we are explicitly resuming
			state.mu.Unlock()

			_ = mpdDo(func(c *mpd.Client) error {
			   // ensure we break out of the current block
			   if err := c.Random(true); err != nil {
			       return err
			   }

			   // advance to next song (randomized start of block)
			   if err := c.Next(); err != nil {
			       return err
			   }

				 // always resume playback
				 return c.Play(-1)
				}, "IPC-nextBlock")

      log.Printf("STATE CHANGE: [IPC-nextBlock] forced block advance, count reset")
	    fmt.Fprintln(conn, "OK")

		case "skip":
			state.mu.Lock()
			state.count = 0
			state.transition = true
			state.mu.Unlock()
			mpdNext("IPC-skip")
			fmt.Fprintln(conn, "Skipped to next block")
//		case "setblock":
//			if len(fields) < 2 {
//				fmt.Fprintln(conn, "Usage: setblock N")
//				continue
//			}
//			n, err := strconv.Atoi(fields[1])
//			if err != nil || n <= 0 {
//				fmt.Fprintln(conn, "Invalid block size")
//				continue
//			}
//			state.mu.Lock()
//			state.blockLimit = n
//			state.count = 0
//			state.mu.Unlock()
//			fmt.Fprintf(conn, "Block limit set to %d\n", n)
//  case "limit":
//    if len(fields) < 2 {
//        fmt.Fprintln(conn, "Usage: limit N")
//        return
//    }
//    n, err := strconv.Atoi(fields[1])
//    if err != nil || n <= 0 {
//        fmt.Fprintln(conn, "Invalid limit")
//        return
//    }
//
//    state.mu.Lock()
//    state.baseLimit = n
//    state.mu.Unlock()
//
//    log.Printf("STATE CHANGE: [IPC] persistent limit set=%d", n)
//    fmt.Fprintln(conn, "Persistent limit set")
//
//  case "setblock", "blocklimit":
//    if len(fields) < 2 {
//      fmt.Fprintln(conn, "Usage: setblock N")
//      continue
//    }
//    n, err := strconv.Atoi(fields[1])
//    if err != nil || n <= 0 {
//      fmt.Fprintln(conn, "Invalid block size")
//      continue
//    }
//
//    state.mu.Lock()
//    state.baseLimit = n        // update the running limit
//    state.count = 0             // reset count so next song starts fresh
//    state.transition = false
//    limit := state.baseLimit
//    state.mu.Unlock()
//
//    log.Printf("STATE CHANGE: [IPC] limit set=%d, count=%d, transition=%v", limit, state.count, state.transition)
//
//    fmt.Fprintf(conn, "Block limit set to %d\nOK\n", n)

		case "limit":
		  if len(fields) < 2 {
		      fmt.Fprintln(conn, "Usage: limit N")
		      return
		  }
		  n, err := strconv.Atoi(fields[1])
		  if err != nil || n <= 0 {
		      fmt.Fprintln(conn, "Invalid limit")
		      return
		  }

		  state.mu.Lock()
		  state.baseLimit = n
		  state.mu.Unlock()

		  log.Printf("STATE CHANGE: [IPC] persistent limit set=%d", n)
		  fmt.Fprintln(conn, "Persistent limit set")

		case "setblock", "blocklimit":
		  if len(fields) < 2 {
		    fmt.Fprintln(conn, "Usage: setblock N")
		    continue
		  }
		  n, err := strconv.Atoi(fields[1])
		  if err != nil || n <= 0 {
		    fmt.Fprintln(conn, "Invalid block size")
		    continue
		  }

		  state.mu.Lock()
      state.blockActive = true   // activate blockLimit immediately
		  state.blockLimit = n       // update the running block limit
		  state.count = 0            // reset count so next song starts fresh
		  state.transition = false
		  block := state.blockLimit
		  state.mu.Unlock()

		  log.Printf("STATE CHANGE: [IPC] block limit set=%d, count=%d, transition=%v", block, state.count, state.transition)
		  fmt.Fprintf(conn, "Block limit set to %d\nOK\n", n)

		case "status":
			state.mu.Lock()
		  limit := state.baseLimit
		  if state.blockActive && state.blockLimit > 0 {
		    limit = state.blockLimit
		  }
			fmt.Fprintf(conn, "paused=%v count=%d limit=%d baseLimit=%d blockLimit=%d lastSongID=%s pollMode=%d\n",
				state.paused, state.count, limit, state.baseLimit, state.blockLimit, state.lastSongID, state.pollMode)
			state.mu.Unlock()

    case "exit", "quit":
      log.Printf("IPC: received %s, shutting down", cmd)
      fmt.Fprintln(conn, "OK")
      close(shutdown)
      return

		default:
			fmt.Fprintln(conn, "Unknown command")
		}
	}
	if err := scanner.Err(); err != nil {
		log.Printf("IPC connection error: %v", err)
	}
}

func sendIPCCommand(cmd string) error {

	conn, err := net.Dial("unix", socketPath)
	if err != nil {
		return err
	}
	defer conn.Close()

	_, err = fmt.Fprintln(conn, cmd)
	if err != nil {
		return err
	}

	// read single-line response
	scanner := bufio.NewScanner(conn)
	if scanner.Scan() {
		fmt.Println(scanner.Text())
	}
	if err := scanner.Err(); err != nil {
		return err
	}

	return nil
}

func writeStateLocked() {
  if !stateEnabled {
    return
  }

  // state.mu MUST already be held
  tmp := statePath + ".tmp"

  f, err := os.OpenFile(tmp, os.O_WRONLY|os.O_CREATE|os.O_TRUNC, 0664)
  if err != nil {
      log.Printf("state write failed: %v", err)
      return
  }

  fmt.Fprintf(f, "lingerpause=%d\n", btoi(state.paused))
  fmt.Fprintf(f, "lingercount=%d\n", state.count)
  fmt.Fprintf(f, "lingerlimit=%d\n", state.baseLimit)
  fmt.Fprintf(f, "lingerbaselimit=%d\n", state.blockLimit)
  fmt.Fprintf(f, "lingerblocklimit=%d\n", state.blockLimit)
  fmt.Fprintf(f, "lingerpid=%d\n", os.Getpid())

  f.Close()
  os.Rename(tmp, statePath)
}

func btoi(b bool) int {
    if b {
        return 1
    }
    return 0
}

//func main() {
//	// CLI subcommands (client mode)
//	if len(os.Args) > 1 {
//		switch os.Args[1] {
//
//    case "pause":
//      if err := sendIPCCommand("pause"); err != nil {
//        log.Fatalf("IPC error: %v", err)
//      }
//      fmt.Println("OK")
//      return
//
//    case "resume":
//      if err := sendIPCCommand("resume"); err != nil {
//        log.Fatalf("IPC error: %v", err)
//      }
//      fmt.Println("OK")
//      return
//
//    case "block":
//      if len(os.Args) >= 4 && os.Args[2] == "--set" {
//        n, err := strconv.Atoi(os.Args[3])
//        if err != nil || n <= 0 {
//          log.Fatalf("Invalid block size: %s", os.Args[3])
//        }
//        // Send IPC command to set running block limit
//        if err := sendIPCCommand(fmt.Sprintf("setblock %d", n)); err != nil {
//          log.Fatalf("IPC error: %v", err)
//        }
//        fmt.Println("OK")
//        return
//      }
//      log.Fatalf("Usage: %s block --set N", os.Args[0])
//
//
//		case "next":
//			if err := sendIPCCommand("next"); err != nil {
//				log.Fatalf("IPC error: %v", err)
//			}
//			fmt.Println("OK")
//			return
//		}
//	}
//
//	// Normal daemon startup
//	var startupLimit int
//	flag.IntVar(&startupLimit, "limit", 0, "Set initial limit at startup")
//	flag.Parse()
//
//	if startupLimit > 0 {
//		state.baseLimit = startupLimit
//	}
//
//	// Connect to MPD for initial state
//	client, err := mpd.Dial("tcp", mpdHost)
//	if err != nil {
//		log.Printf("Failed to connect to MPD at startup: %v", err)
//		state.count = 0
//		state.lastSongID = ""
//	} else {
//		status, err := client.Status()
//		if err != nil {
//			log.Printf("Status error at startup: %v", err)
//			state.count = 0
//			state.lastSongID = ""
//		} else {
//			state.lastSongID = status["songid"]
//			switch status["state"] {
//			case "paused", "stop":
//				state.count = 0
//			default:
//				state.count = 1
//			}
//		}
//		client.Close()
//	}
//
//	log.Printf("Starting block count=%d, lastSongID=%s, limit=%d", state.count, state.lastSongID, limit)
//	setRandom(false, "startup")
//
//	// Start IPC listener
//	socketPath := "/tmp/mpdgolinger.sock"
//	os.Remove(socketPath)
//	go startIPC(socketPath)
//
//	// Start idle supervisor
//	go idleSupervisor()
//
//	// Block forever
//	select {}
//}

func main() {
  // CLI subcommands (client mode)
  if len(os.Args) > 1 {
    switch os.Args[1] {

		case "status":
		  if err := sendIPCCommand("status"); err != nil {
		    log.Fatalf("IPC error: %v", err)
		  }
		  return

    case "pause":
      if err := sendIPCCommand("pause"); err != nil {
        log.Fatalf("IPC error: %v", err)
      }
      fmt.Println("OK")
      return

    case "resume":
      if err := sendIPCCommand("resume"); err != nil {
        log.Fatalf("IPC error: %v", err)
      }
      fmt.Println("OK")
      return

		case "limit":
		  if len(os.Args) < 3 {
		    log.Fatal("Usage: mpdgolinger limit N")
		  }
		  n, err := strconv.Atoi(os.Args[2])
		  if err != nil || n <= 0 {
		    log.Fatalf("Invalid limit: %q", os.Args[2])
		  }
		  sendIPCCommand(fmt.Sprintf("limit %d", n))
		  return

    case "block", "blocklimit":
      if len(os.Args) >= 3 {
        n, err := strconv.Atoi(os.Args[2])
        if err != nil || n <= 0 {
          log.Fatalf("Invalid block size: %s", os.Args[2])
        }
        // Send IPC command to set running block limit
        if err := sendIPCCommand(fmt.Sprintf("setblock %d", n)); err != nil {
          log.Fatalf("IPC error: %v", err)
        }
        fmt.Println("OK")
        return
      }
      log.Fatalf("Usage: %s %s N", os.Args[0], os.Args[1])

    case "next":
      if err := sendIPCCommand("next"); err != nil {
        log.Fatalf("IPC error: %v", err)
      }
      fmt.Println("OK")
      return
    }
  }

  // Normal daemon startup
  var startupLimit int
  flag.IntVar(&startupLimit, "limit", 0, "Set initial persistent limit at startup")
  flag.Parse()

  if startupLimit > 0 {
    state.baseLimit = startupLimit
  }

  // Connect to MPD for initial state
  client, err := mpd.Dial("tcp", mpdHost)
  if err != nil {
    log.Printf("Failed to connect to MPD at startup: %v", err)
    state.count = 0
    state.lastSongID = ""
  } else {
    status, err := client.Status()
    if err != nil {
      log.Printf("Status error at startup: %v", err)
      state.count = 0
      state.lastSongID = ""
    } else {
      state.lastSongID = status["songid"]
      switch status["state"] {
      case "paused", "stop":
        state.count = 0
      default:
        state.count = 1
      }
    }
    client.Close()
  }

  log.Printf("Starting block count=%d, lastSongID=%s, baseLimit=%d, blockLimit=%d",
    state.count, state.lastSongID, state.baseLimit, state.blockLimit)
  setRandom(false, "startup")

  // Start IPC listener
  os.Remove(socketPath)
  go startIPC(socketPath)

  // Start idle supervisor
  go idleSupervisor()

  // Block forever
//  select {}

  // Block until shutdown received
  select {
  case <-shutdown:
    log.Println("Shutdown requested")
  }


}



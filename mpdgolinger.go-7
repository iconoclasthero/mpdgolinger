package main

import (
	"bufio"
	"flag"
	"fmt"
	"log"
	"net"
	"os"
	"strconv"
	"strings"
	"sync"
	"time"

	"github.com/fhs/gompd/v2/mpd"
)

/* =========================
   State + logging
   ========================= */

type State struct {
	mu         sync.Mutex
	count      int
	limit      int
	transition bool
	lastSongID string
}

type StateSnap struct {
	count      int
	limit      int
	transition bool
	lastSongID string
}

func snap() StateSnap {
	return StateSnap{
		count:      state.count,
		limit:      state.limit,
		transition: state.transition,
		lastSongID: state.lastSongID,
	}
}

func logChange(src, action string, before StateSnap) {
	log.Printf(
		"STATE CHANGE: [%s] %s songid=%s count=%d→%d limit=%d→%d transition=%v",
		src,
		action,
		state.lastSongID,
		before.count, state.count,
		before.limit, state.limit,
		state.transition,
	)
}

var (
	state   = &State{limit: 3}
	mpdHost = "localhost:6600"
)

/* =========================
   Main
   ========================= */

func main() {
	// client subcommands
	if len(os.Args) > 1 {
		switch os.Args[1] {
		case "status", "limit":
			runCLI(os.Args[1:])
			return
		}
	}

	// daemon startup flags
	startFlags := flag.NewFlagSet("mpdgolinger", flag.ExitOnError)
	startLimit := startFlags.Int("limit", 0, "initial block limit")
	startFlags.Parse(os.Args[1:])

	if *startLimit > 0 {
		state.limit = *startLimit
	}

	client, err := mpd.Dial("tcp", mpdHost)
	if err != nil {
		log.Fatalf("MPD connect failed: %v", err)
	}
	defer client.Close()

	initState(client)

	socket := "/tmp/mpdgolinger.sock"
	os.Remove(socket)
	go startIPC(socket)
	go idleSupervisor()

	select {}
}

func initState(c *mpd.Client) {
	status, err := c.Status()
	if err != nil {
		log.Printf("startup status error: %v", err)
		return
	}

	state.mu.Lock()
	defer state.mu.Unlock()

	state.lastSongID = status["songid"]
	if status["state"] == "play" {
		state.count = 1
	}
	log.Printf("Starting block count=%d, lastSongID=%s limit=%d",
		state.count, state.lastSongID, state.limit)
}

/* =========================
   CLI
   ========================= */

func runCLI(args []string) {
	switch args[0] {
	case "status":
		ipcSend("status")
	case "limit":
		cmdLimit(args[1:])
	}
}

func cmdLimit(args []string) {
	fs := flag.NewFlagSet("limit", flag.ExitOnError)
	set := fs.Int("set", -1, "")
	get := fs.Bool("get", false, "")
	fs.Parse(args)

	if *set > 0 {
		ipcSend(fmt.Sprintf("limit set %d", *set))
		return
	}
	if *get {
		ipcSend("limit get")
		return
	}
	fmt.Println("usage: limit --set N | --get")
}

func ipcSend(cmd string) {
	c, err := net.Dial("unix", "/tmp/mpdgolinger.sock")
	if err != nil {
		log.Fatal(err)
	}
	defer c.Close()

	fmt.Fprintln(c, cmd)

	sc := bufio.NewScanner(c)
	for sc.Scan() {
		fmt.Println(sc.Text())
	}
}

/* =========================
   IPC server
   ========================= */

func startIPC(path string) {
	ln, err := net.Listen("unix", path)
	if err != nil {
		log.Fatalf("IPC listen failed: %v", err)
	}
	log.Printf("IPC listening on %s", path)

	for {
		c, err := ln.Accept()
		if err != nil {
			continue
		}
		go handleConn(c)
	}
}

func handleConn(c net.Conn) {
	defer c.Close()

	sc := bufio.NewScanner(c)
	if !sc.Scan() {
		return
	}

	f := strings.Fields(sc.Text())
	if len(f) == 0 {
		return
	}

	switch f[0] {
	case "status":
		state.mu.Lock()
		fmt.Fprintf(c, "count=%d limit=%d transition=%v songid=%s\n",
			state.count, state.limit, state.transition, state.lastSongID)
		state.mu.Unlock()
	case "limit":
		handleLimit(c, f)
	}
}

func handleLimit(c net.Conn, f []string) {
	if len(f) < 2 {
		fmt.Fprintln(c, "ERR")
		return
	}

	state.mu.Lock()
	defer state.mu.Unlock()
	before := snap()

	switch f[1] {
	case "get":
		fmt.Fprintf(c, "limit=%d\n", state.limit)
	case "set":
		n, err := strconv.Atoi(f[2])
		if err != nil || n <= 0 {
			fmt.Fprintln(c, "ERR")
			return
		}
		state.limit = n
		logChange("ipc", "limit-set", before)
		fmt.Fprintln(c, "OK")
	}
}

/* =========================
   MPD idle supervisor
   ========================= */

func idleSupervisor() {
	for {
		log.Println("Connecting to MPD idle watcher…")
		w, err := mpd.NewWatcher("tcp", mpdHost, "", "player")
		if err != nil {
			time.Sleep(2 * time.Second)
			continue
		}
		if err := runIdle(w); err != nil {
			log.Printf("idle loop exited: %v", err)
		}
		w.Close()
		time.Sleep(2 * time.Second)
	}
}

func runIdle(w *mpd.Watcher) error {
	for range w.Event {
		client, err := mpd.Dial("tcp", mpdHost)
		if err != nil {
			continue
		}
		status, err := client.Status()
		client.Close()
		if err != nil {
			continue
		}

		songID := status["songid"]

		state.mu.Lock()
		if songID == state.lastSongID {
			state.mu.Unlock()
			continue
		}

		before := snap()
		state.lastSongID = songID

		if state.transition {
			state.count = 1
			state.transition = false
			logChange("idle", "new-block", before)
		} else if state.count == state.limit-1 {
			state.count++
			state.transition = true
			logChange("idle", "last-song", before)
		} else {
			state.count++
			logChange("idle", "song-advance", before)
		}

		state.mu.Unlock()
	}
	return fmt.Errorf("watcher closed")
}

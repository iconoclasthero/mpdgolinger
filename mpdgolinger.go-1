package main

import (
	"bufio"
	"fmt"
	"log"
	"net"
	"os"
	"strconv"
	"strings"
	"sync"
	"time"

	"github.com/fhs/gompd/v2/mpd"
)

// State holds daemon state
type State struct {
	mu         sync.Mutex
	paused     bool
	count      int        // current position in block
  limit      int        // persistent block size (your old "limit")
	blockLimit int        // temporary override (later)
  transition bool       // true between last-song-start and next-song-start
	lastSongID string
	pollMode   int
}

const (
	PollOff = iota
	PollLogging
	PollOn
)

var (
	state   = &State{limit: 3, pollMode: PollOff}
	mpdHost = "localhost:6600"
)

//func main() {
//	// Connect to MPD
//	client, err := mpd.Dial("tcp", mpdHost)
//	if err != nil {
//		log.Fatalf("Failed to connect to MPD: %v", err)
//	}
//	defer client.Close()
//
//	// Start IPC listener
//	socketPath := "/tmp/mpdgolinger.sock"
//	os.Remove(socketPath)
//	go startIPC(socketPath)
//
//	// Start optional polling goroutine
//	go poller(client)
//
//	// Start idle loop
//	idleLoop()
//}

func main() {
  // Connect to MPD
  client, err := mpd.Dial("tcp", mpdHost)
  if err != nil {
    log.Fatalf("Failed to connect to MPD: %v", err)
  }
  defer client.Close()

status, err := client.Status()
if err != nil {
    log.Printf("Status error at startup: %v", err)
    state.count = 0
    state.lastSongID = "" // no baseline
} else {
    state.lastSongID = status["songid"] // set baseline for all cases
    switch status["state"] {
    case "paused", "stop":
        state.count = 0
    default: // playing
        state.count = 1
    }
}
log.Printf("Starting block count=%d, lastSongID=%s", state.count, state.lastSongID)

  // Start IPC listener
  socketPath := "/tmp/mpdgolinger.sock"
  os.Remove(socketPath)
  go startIPC(socketPath)

  // Start optional polling goroutine
  go poller(client)

  // Start idle loop
//  idleLoop()
  go idleSupervisor()


  // Block forever
  select {}

}


//func idleLoop() {
//	w, err := mpd.NewWatcher("tcp", mpdHost, "", "player")
//	if err != nil {
//		log.Fatalf("watcher init failed: %v", err)
//	}
//	defer w.Close()
//
//	go func() {
//		for err := range w.Error {
//			log.Printf("watcher error: %v", err)
//		}
//	}()
//
//	for range w.Event {
//		// short-lived command connection (important)
//		client, err := mpd.Dial("tcp", mpdHost)
//		if err != nil {
//			log.Printf("mpd dial failed: %v", err)
//			continue
//		}
//
//		status, err := client.Status()
//		if err != nil {
//			log.Printf("status error: %v", err)
//			client.Close()
//			continue
//		}
//
//		songID := status["songid"]
//
//		state.mu.Lock()
//
//		// ignore duplicate events
//		if songID == state.lastSongID {
//			state.mu.Unlock()
//			client.Close()
//			continue
//		}
//
//		state.lastSongID = songID
//
//		/*
//		   STATE MACHINE (mirrors bash):
//
//		   count < limit-1 : normal song
//		   count == limit-1: last song starts → random ON
//		   transition=true : next song starts → random OFF, count=1
//		*/
//
//		if state.transition {
//			// first song of new block
//			_ = client.Random(false)
//			state.count = 1
//			state.transition = false
//			log.Printf("New block started — random OFF, count=%d", state.count)
//
//		} else if state.count == state.limit-1 {
//			// last song just started
//			state.count++
//			_ = client.Random(true)
//			state.transition = true
//			log.Printf("Song %d/%d — last song, random ON", state.count, state.limit)
//
//		} else {
//			// normal in-block song
//			state.count++
//			log.Printf("Song %d/%d in current block", state.count, state.limit)
//		}
//
//		state.mu.Unlock()
//		client.Close()
//	}
//}

//func idleSupervisor() {
//    for {
//        err := idleLoop()
//        if err != nil {
//            log.Printf("Idle loop exited with error: %v", err)
//        } else {
//            log.Printf("Idle loop exited cleanly")
//        }
//
//        // Wait a few seconds before retrying
//        time.Sleep(3 * time.Second)
//        log.Printf("Attempting to reconnect to MPD...")
//    }
//}

func idleSupervisor() {
    for {
        log.Println("Connecting to MPD for idle loop...")
        w, err := mpd.NewWatcher("tcp", mpdHost, "", "player")
        if err != nil {
            log.Printf("Watcher init failed: %v — retrying in 2s", err)
            time.Sleep(2 * time.Second)
            continue
        }

        // run idle loop until it fails
        if err := runIdleLoop(w); err != nil {
            log.Printf("Idle loop exited: %v — reconnecting in 2s", err)
        }

        w.Close()
        time.Sleep(2 * time.Second)
    }
}

func runIdleLoop(w *mpd.Watcher) error {
    for range w.Event {
        // short-lived MPD connection for commands
        client, err := mpd.Dial("tcp", mpdHost)
        if err != nil {
            log.Printf("mpd dial failed: %v", err)
            continue
        }

        // handle events here...
        client.Close()
    }
    return fmt.Errorf("watcher closed")
}


// idleLoop waits for MPD player events and updates state
func idleLoop() error {
    w, err := mpd.NewWatcher("tcp", mpdHost, "", "player")
    if err != nil {
        return fmt.Errorf("watcher init failed: %w", err)
    }
    defer w.Close()

    go func() {
        for err := range w.Error {
            log.Printf("watcher error: %v", err)
        }
    }()

    for range w.Event {
        client, err := mpd.Dial("tcp", mpdHost)
        if err != nil {
            log.Printf("mpd dial failed: %v", err)
            continue
        }

        status, err := client.Status()
        if err != nil {
            log.Printf("status error: %v", err)
            client.Close()
            continue
        }

        songID := status["songid"]

        state.mu.Lock()
        if songID == state.lastSongID {
            state.mu.Unlock()
            client.Close()
            continue
        }

        state.lastSongID = songID

        if state.transition {
            _ = client.Random(false)
            state.count = 1
            state.transition = false
            log.Printf("New block started — random OFF, count=%d", state.count)

        } else if state.count == state.limit-1 {
            state.count++
            _ = client.Random(true)
            state.transition = true
            log.Printf("Song %d/%d — last song, random ON", state.count, state.limit)

        } else {
            state.count++
            log.Printf("Song %d/%d in current block", state.count, state.limit)
        }

        state.mu.Unlock()
        client.Close()
    }

    return nil // return when w.Event channel closes
}


// poller optionally polls MPD based on pollMode
func poller(client *mpd.Client) {
	for {
		state.mu.Lock()
		mode := state.pollMode
		state.mu.Unlock()

		if mode == PollOff {
			time.Sleep(time.Second)
			continue
		}

		status, err := client.Status()
		if err != nil {
			log.Printf("Poll status error: %v", err)
			time.Sleep(time.Second)
			continue
		}

		songID := status["songid"]

		state.mu.Lock()
		if mode == PollLogging {
			log.Printf("Poll logging: songid=%s", songID)
		} else if mode == PollOn && songID != state.lastSongID && !state.paused {
			state.count++
			if state.count >= state.blockLimit {
				state.count = 0
				log.Println("Poll: block finished — starting new block")
			} else {
				log.Printf("Poll: song %d/%d in current block", state.count, state.blockLimit)
			}
		}
		state.lastSongID = songID
		state.mu.Unlock()

		time.Sleep(1 * time.Second)
	}
}

// startIPC listens on UNIX socket for client commands
func startIPC(path string) {
	ln, err := net.Listen("unix", path)
	if err != nil {
		log.Fatalf("Failed to listen on %s: %v", path, err)
	}
	defer ln.Close()
	log.Printf("IPC listening on %s", path)

	for {
		conn, err := ln.Accept()
		if err != nil {
			log.Printf("IPC accept error: %v", err)
			continue
		}
		go handleConn(conn)
	}
}

// handleConn parses commands and updates state
func handleConn(conn net.Conn) {
	defer conn.Close()
	scanner := bufio.NewScanner(conn)
	for scanner.Scan() {
		line := scanner.Text()
		fields := strings.Fields(line)
		if len(fields) == 0 {
			continue
		}

		cmd := strings.ToLower(fields[0])
		switch cmd {
		case "pause":
			state.mu.Lock()
			state.paused = true
			state.mu.Unlock()
			fmt.Fprintln(conn, "Paused")
		case "resume":
			state.mu.Lock()
			state.paused = false
			state.mu.Unlock()
			fmt.Fprintln(conn, "Resumed")
		case "skip":
			state.mu.Lock()
			state.count = 0
			state.mu.Unlock()
			fmt.Fprintln(conn, "Skipped to next block")
		case "setblock":
			if len(fields) < 2 {
				fmt.Fprintln(conn, "Usage: setblock N")
				continue
			}
			n, err := strconv.Atoi(fields[1])
			if err != nil || n <= 0 {
				fmt.Fprintln(conn, "Invalid block size")
				continue
			}
			state.mu.Lock()
			state.blockLimit = n
			state.count = 0
			state.mu.Unlock()
			fmt.Fprintf(conn, "Block limit set to %d\n", n)
		case "status":
			state.mu.Lock()
			fmt.Fprintf(conn, "paused=%v count=%d blockLimit=%d lastSongID=%s pollMode=%d\n",
				state.paused, state.count, state.blockLimit, state.lastSongID, state.pollMode)
			state.mu.Unlock()
		case "pollmode":
			if len(fields) < 2 {
				fmt.Fprintln(conn, "Usage: pollmode off|logging|on")
				continue
			}
			var mode int
			switch strings.ToLower(fields[1]) {
			case "off":
				mode = PollOff
			case "logging":
				mode = PollLogging
			case "on":
				mode = PollOn
			default:
				fmt.Fprintln(conn, "Invalid poll mode")
				continue
			}
			state.mu.Lock()
			state.pollMode = mode
			state.mu.Unlock()
			fmt.Fprintf(conn, "Poll mode set to %s\n", fields[1])
		default:
			fmt.Fprintln(conn, "Unknown command")
		}
	}
	if err := scanner.Err(); err != nil {
		log.Printf("IPC connection error: %v", err)
	}
}
